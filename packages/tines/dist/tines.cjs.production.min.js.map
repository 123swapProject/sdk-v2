{"version":3,"file":"tines.cjs.production.min.js","sources":["../src/MultiRouterTypes.ts","../src/MultiRouterMath.ts","../src/MultiRouter.ts"],"sourcesContent":["import { BigNumber } from \"@ethersproject/bignumber\";\n\nexport interface RToken {\n  name: string;\n  address: string;\n}\n\nexport enum PoolType {\n  ConstantProduct = \"ConstantProduct\",\n  Weighted = \"Weighted\",\n  Hybrid = \"Hybrid\",\n  ConcentratedLiquidity = \"ConcentratedLiquidity\",\n}\n\nexport interface PoolInfo {\n  address: string;\n  token0: RToken;\n  token1: RToken;\n  type: PoolType;\n  reserve0: BigNumber;\n  reserve1: BigNumber;\n  fee: number;\n  minLiquidity: number;\n  swapGasCost: number;\n}\n\ntype Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\ntype PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\ntype PoolInfoWithDefaults = PartialBy<PoolInfo, \"minLiquidity\" | \"swapGasCost\">;\n\nexport class Pool {\n  address: string;\n  token0: RToken;\n  token1: RToken;\n  type: PoolType;\n  reserve0: BigNumber;\n  reserve1: BigNumber;\n  fee: number;\n  minLiquidity: number;\n  swapGasCost: number;\n\n  constructor(_info: PoolInfoWithDefaults) {\n    const info = {\n      minLiquidity: 1000,\n      swapGasCost: 40_000,\n      ..._info,\n    };\n    this.address = info.address;\n    this.token0 = info.token0;\n    this.token1 = info.token1;\n    this.type = info.type;\n    this.reserve0 = info.reserve0;\n    this.reserve1 = info.reserve1;\n    this.fee = info.fee;\n    this.minLiquidity = info.minLiquidity;\n    this.swapGasCost = info.swapGasCost;\n  }\n}\n\ntype PoolInfoNoType = Omit<PoolInfoWithDefaults, \"type\">;\n\nexport class RConstantProductPool extends Pool {\n  constructor(info: PoolInfoNoType) {\n    super({\n      type: PoolType.ConstantProduct,\n      ...info,\n    });\n  }\n}\n\ntype HybridPoolInfo = PoolInfoNoType & { A: number };\n\nexport class RHybridPool extends Pool {\n  A: number;\n  constructor(info: HybridPoolInfo) {\n    super({\n      type: PoolType.Hybrid,\n      ...info,\n    });\n    this.A = info.A;\n  }\n}\n\ntype WeightedPoolInfo = PoolInfoNoType & { weight0: number; weight1: number };\n\nexport class RWeightedPool extends Pool {\n  weight0: number;\n  weight1: number;\n  constructor(info: WeightedPoolInfo) {\n    super({\n      type: PoolType.Weighted,\n      ...info,\n    });\n    this.weight0 = info.weight0;\n    this.weight1 = info.weight1;\n  }\n}\n\nexport const CL_MIN_TICK = -887272;\nexport const CL_MAX_TICK = -CL_MIN_TICK - 1;\ninterface CLTick {\n  index: number;\n  DLiquidity: number;\n}\n\ninterface CLSpecific {\n  liquidity: number;\n  sqrtPrice: number;\n  nearestTick: number;\n  ticks: CLTick[];\n}\n\ntype CLPoolInfo = Omit<PoolInfoNoType, \"reserve0\" | \"reserve1\"> & CLSpecific;\n\nexport class RConcentratedLiquidityPool extends Pool {\n  liquidity: number;\n  sqrtPrice: number;\n  nearestTick: number;\n  ticks: CLTick[];\n  constructor(info: CLPoolInfo) {\n    super({\n      type: PoolType.ConcentratedLiquidity,\n      reserve0: BigNumber.from(0),\n      reserve1: BigNumber.from(0),\n      ...info,\n    });\n    this.liquidity = info.liquidity;\n    this.sqrtPrice = info.sqrtPrice;\n    this.nearestTick = info.nearestTick;\n    this.ticks = info.ticks;\n  }\n}\n\nexport interface RouteLeg {\n  address: string;\n  token: RToken;\n  swapPortion: number; // For router contract\n  absolutePortion: number; // To depict at webpage for user\n}\n\nexport enum RouteStatus {\n  Success = \"Success\",\n  NoWay = \"NoWay\",\n  Partial = \"Partial\",\n}\nexport interface MultiRoute {\n  status: RouteStatus;\n  amountIn: number;\n  amountOut: number;\n  legs: RouteLeg[];\n  gasSpent: number;\n  totalAmountOut: number;\n}\n","import {\n  CL_MAX_TICK,\n  CL_MIN_TICK,\n  Pool,\n  PoolType,\n  RConcentratedLiquidityPool,\n  RHybridPool,\n  RWeightedPool,\n} from \"./MultiRouterTypes\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\n\nconst A_PRECISION = 100;\n\nconst DCacheBN = new Map<Pool, BigNumber>();\nexport function HybridComputeLiquidity(pool: RHybridPool): BigNumber {\n  const res = DCacheBN.get(pool);\n  if (res !== undefined) return res;\n\n  const r0 = pool.reserve0;\n  const r1 = pool.reserve1;\n\n  if (r0.isZero() && r1.isZero()) {\n    DCacheBN.set(pool, BigNumber.from(0));\n    return BigNumber.from(0);\n  }\n  const s = r0.add(r1);\n\n  const nA = BigNumber.from(pool.A * 2);\n\n  let prevD;\n\n  let D = s;\n  for (let i = 0; i < 256; i++) {\n    const dP = D.mul(D).div(r0).mul(D).div(r1).div(4);\n    prevD = D;\n    D = nA\n      .mul(s)\n      .div(A_PRECISION)\n      .add(dP.mul(2))\n      .mul(D)\n      .div(nA.div(A_PRECISION).sub(1).mul(D).add(dP.mul(3)));\n    if (D.sub(prevD).abs().lte(1)) {\n      break;\n    }\n  }\n  DCacheBN.set(pool, D);\n  return D;\n}\n\nexport function HybridgetY(pool: RHybridPool, x: BigNumber): BigNumber {\n  const D = HybridComputeLiquidity(pool);\n\n  const nA = pool.A * 2;\n\n  let c = D.mul(D)\n    .div(x.mul(2))\n    .mul(D)\n    .div((nA * 2) / A_PRECISION);\n  let b = D.mul(A_PRECISION).div(nA).add(x);\n\n  let yPrev;\n  let y = D;\n  for (let i = 0; i < 256; i++) {\n    yPrev = y;\n\n    y = y.mul(y).add(c).div(y.mul(2).add(b).sub(D));\n    if (y.sub(yPrev).abs().lte(1)) {\n      break;\n    }\n  }\n  return y;\n}\n\nexport function calcOutByIn(\n  pool: Pool,\n  amountIn: number,\n  direction = true\n): number {\n  const xBN = direction ? pool.reserve0 : pool.reserve1;\n  const yBN = direction ? pool.reserve1 : pool.reserve0;\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString());\n      const y = parseInt(yBN.toString());\n      return (y * amountIn) / (x / (1 - pool.fee) + amountIn);\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString());\n      const y = parseInt(yBN.toString());\n      const wPool = pool as RWeightedPool;\n      const weightRatio = direction\n        ? wPool.weight0 / wPool.weight1\n        : wPool.weight1 / wPool.weight0;\n      const actualIn = amountIn * (1 - pool.fee);\n      const out = y * (1 - Math.pow(x / (x + actualIn), weightRatio));\n      return out;\n    }\n    case PoolType.Hybrid: {\n      // const xNew = x + amountIn*(1-pool.fee);\n      // const yNew = HybridgetY(pool, xNew);\n      // const dy = y - yNew;\n\n      const xNewBN = xBN.add(\n        getBigNumber(undefined, amountIn * (1 - pool.fee))\n      );\n      const yNewBN = HybridgetY(pool as RHybridPool, xNewBN);\n      const dy = parseInt(yBN.sub(yNewBN).toString());\n\n      return dy;\n    }\n    case PoolType.ConcentratedLiquidity: {\n      return ConcentratedLiquidityOutByIn(\n        pool as RConcentratedLiquidityPool,\n        amountIn,\n        direction\n      );\n    }\n  }\n}\n\nexport class OutOfLiquidity extends Error {}\n\nfunction ConcentratedLiquidityOutByIn(\n  pool: RConcentratedLiquidityPool,\n  inAmount: number,\n  direction: boolean\n) {\n  if (pool.ticks.length === 0) return 0;\n  if (pool.ticks[0].index > CL_MIN_TICK)\n    pool.ticks.unshift({ index: CL_MIN_TICK, DLiquidity: 0 });\n  if (pool.ticks[pool.ticks.length - 1].index < CL_MAX_TICK)\n    pool.ticks.push({ index: CL_MAX_TICK, DLiquidity: 0 });\n\n  let nextTickToCross = direction ? pool.nearestTick : pool.nearestTick + 1;\n  let currentPrice = pool.sqrtPrice;\n  let currentLiquidity = pool.liquidity;\n  let outAmount = 0;\n  let input = inAmount;\n\n  while (input > 0) {\n    if (nextTickToCross < 0 || nextTickToCross >= pool.ticks.length)\n      throw new OutOfLiquidity();\n\n    const nextTickPrice = Math.sqrt(\n      Math.pow(1.0001, pool.ticks[nextTickToCross].index)\n    );\n    // console.log('L, P, tick, nextP', currentLiquidity,\n    //     currentPrice, pool.ticks[nextTickToCross].index, nextTickPrice);\n    let output = 0;\n\n    if (direction) {\n      const maxDx =\n        (currentLiquidity * (currentPrice - nextTickPrice)) /\n        currentPrice /\n        nextTickPrice;\n      //console.log('input, maxDx', input, maxDx);\n\n      if (input <= maxDx) {\n        output =\n          (currentLiquidity * currentPrice * input) /\n          (input + currentLiquidity / currentPrice);\n        input = 0;\n      } else {\n        output = currentLiquidity * (currentPrice - nextTickPrice);\n        currentPrice = nextTickPrice;\n        input -= maxDx;\n        if (pool.ticks[nextTickToCross].index % 2 === 0) {\n          currentLiquidity -= pool.ticks[nextTickToCross].DLiquidity;\n        } else {\n          currentLiquidity += pool.ticks[nextTickToCross].DLiquidity;\n        }\n        nextTickToCross--;\n      }\n    } else {\n      const maxDy = currentLiquidity * (nextTickPrice - currentPrice);\n      //console.log('input, maxDy', input, maxDy);\n      if (input <= maxDy) {\n        output =\n          input / currentPrice / (currentPrice + input / currentLiquidity);\n        input = 0;\n      } else {\n        output =\n          (currentLiquidity * (nextTickPrice - currentPrice)) /\n          currentPrice /\n          nextTickPrice;\n        currentPrice = nextTickPrice;\n        input -= maxDy;\n        if (pool.ticks[nextTickToCross].index % 2 === 0) {\n          currentLiquidity += pool.ticks[nextTickToCross].DLiquidity;\n        } else {\n          currentLiquidity -= pool.ticks[nextTickToCross].DLiquidity;\n        }\n        nextTickToCross++;\n      }\n    }\n\n    outAmount += output * (1 - pool.fee);\n    //console.log('out', outAmount);\n  }\n\n  return outAmount;\n}\n\nexport function calcInByOut(\n  pool: Pool,\n  amountOut: number,\n  direction: boolean\n): number {\n  let input = 0;\n  const xBN = direction ? pool.reserve0 : pool.reserve1;\n  const yBN = direction ? pool.reserve1 : pool.reserve0;\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = parseInt(xBN.toString());\n      const y = parseInt(yBN.toString());\n      input = (x * amountOut) / (1 - pool.fee) / (y - amountOut);\n      break;\n    }\n    case PoolType.Weighted: {\n      const x = parseInt(xBN.toString());\n      const y = parseInt(yBN.toString());\n      const wPool = pool as RWeightedPool;\n      const weightRatio = direction\n        ? wPool.weight0 / wPool.weight1\n        : wPool.weight1 / wPool.weight0;\n      input =\n        x * (1 - pool.fee) * (Math.pow(1 - amountOut / y, -weightRatio) - 1);\n      break;\n    }\n    case PoolType.Hybrid: {\n      let yNewBN = yBN.sub(getBigNumber(undefined, amountOut));\n      if (yNewBN.lt(1))\n        // lack of precision\n        yNewBN = BigNumber.from(1);\n\n      const xNewBN = HybridgetY(pool as RHybridPool, yNewBN);\n      input = Math.round(parseInt(xNewBN.sub(xBN).toString()) / (1 - pool.fee));\n\n      // const yNew = y - amountOut;\n      // const xNew = HybridgetY(pool, yNew);\n      // input = (xNew - x)/(1-pool.fee);\n      break;\n    }\n    default:\n      console.error(\"Unknown pool type\");\n  }\n\n  // ASSERT(() => {\n  //   const amount2 = calcOutByIn(pool, input, direction);\n  //   const res = closeValues(amountOut, amount2, 1e-6);\n  //   if (!res) console.log(\"Error 138:\", amountOut, amount2, Math.abs(amountOut/amount2 - 1));\n  //   return res;\n  // });\n  if (input < 1) input = 1;\n  return input;\n}\n\nexport function calcPrice(\n  pool: Pool,\n  amountIn: number,\n  takeFeeIntoAccount = true\n): number {\n  const r0 = parseInt(pool.reserve0.toString());\n  const r1 = parseInt(pool.reserve1.toString());\n  const oneMinusFee = takeFeeIntoAccount ? 1 - pool.fee : 1;\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const x = r0 / oneMinusFee;\n      return (r1 * x) / (x + amountIn) / (x + amountIn);\n    }\n    case PoolType.Weighted: {\n      const wPool = pool as RWeightedPool;\n      const weightRatio = wPool.weight0 / wPool.weight1;\n      const x = r0 + amountIn * oneMinusFee;\n      return (\n        (r1 * weightRatio * oneMinusFee * Math.pow(r0 / x, weightRatio)) / x\n      );\n    }\n    case PoolType.Hybrid: {\n      const hPool = pool as RHybridPool;\n      const D = parseInt(HybridComputeLiquidity(hPool).toString());\n      const A = hPool.A / A_PRECISION;\n      const x = r0 + amountIn;\n      const b = 4 * A * x + D - 4 * A * D;\n      const ac4 = (D * D * D) / x;\n      const Ds = Math.sqrt(b * b + 4 * A * ac4);\n      const res = (0.5 - (2 * b - ac4 / x) / Ds / 4) * oneMinusFee;\n      return res;\n    }\n  }\n  return 0;\n}\n\nfunction calcInputByPriceConstantMean(pool: RWeightedPool, price: number) {\n  const r0 = parseInt(pool.reserve0.toString());\n  const r1 = parseInt(pool.reserve1.toString());\n  const weightRatio = pool.weight0 / pool.weight1;\n  const t =\n    r1 * price * weightRatio * (1 - pool.fee) * Math.pow(r0, weightRatio);\n  return (Math.pow(t, 1 / (weightRatio + 1)) - r0) / (1 - pool.fee);\n}\n\nexport function calcInputByPrice(\n  pool: Pool,\n  priceEffective: number,\n  hint = 1\n): number {\n  switch (pool.type) {\n    case PoolType.ConstantProduct: {\n      const r0 = parseInt(pool.reserve0.toString());\n      const r1 = parseInt(pool.reserve1.toString());\n      const x = r0 / (1 - pool.fee);\n      const res = Math.sqrt(r1 * x * priceEffective) - x;\n      return res;\n    }\n    case PoolType.Weighted: {\n      const res = calcInputByPriceConstantMean(\n        pool as RWeightedPool,\n        priceEffective\n      );\n      return res;\n    }\n    case PoolType.Hybrid: {\n      return revertPositive(\n        (x: number) => 1 / calcPrice(pool, x),\n        priceEffective,\n        hint\n      );\n    }\n  }\n  return 0;\n}\n\n//================================= Utils ====================================\n\nexport function ASSERT(f: () => boolean, t?: string) {\n  if (!f() && t) console.error(t);\n}\n\nexport function closeValues(a: number, b: number, accuracy: number): boolean {\n  if (accuracy === 0) return a === b;\n  if (a < 1 / accuracy) return Math.abs(a - b) <= 10;\n  return Math.abs(a / b - 1) < accuracy;\n}\n\nexport function calcSquareEquation(\n  a: number,\n  b: number,\n  c: number\n): [number, number] {\n  const D = b * b - 4 * a * c;\n  console.assert(D >= 0, `Discriminant is negative! ${a} ${b} ${c}`);\n  const sqrtD = Math.sqrt(D);\n  return [(-b - sqrtD) / 2 / a, (-b + sqrtD) / 2 / a];\n}\n\n// returns such x > 0 that f(x) = out or 0 if there is no such x or f defined not everywhere\n// hint - approximation of x to spead up the algorithm\n// f assumed to be continues monotone growth function defined everywhere\nexport function revertPositive(\n  f: (x: number) => number,\n  out: number,\n  hint = 1\n) {\n  try {\n    if (out <= f(0)) return 0;\n    let min, max;\n    if (f(hint) > out) {\n      min = hint / 2;\n      while (f(min) > out) min /= 2;\n      max = min * 2;\n    } else {\n      max = hint * 2;\n      while (f(max) < out) max *= 2;\n      min = max / 2;\n    }\n\n    while (max / min - 1 > 1e-4) {\n      const x0: number = (min + max) / 2;\n      const y0 = f(x0);\n      if (out === y0) return x0;\n      if (out < y0) max = x0;\n      else min = x0;\n    }\n    return (min + max) / 2;\n  } catch (e) {\n    return 0;\n  }\n}\n\nexport function getBigNumber(\n  valueBN: BigNumber | undefined,\n  value: number\n): BigNumber {\n  if (valueBN !== undefined) return valueBN;\n\n  if (value < Number.MAX_SAFE_INTEGER) return BigNumber.from(Math.round(value));\n\n  const exp = Math.floor(Math.log(value) / Math.LN2);\n  console.assert(exp >= 51, \"Internal Error 314\");\n  const shift = exp - 51;\n  const mant = Math.round(value / Math.pow(2, shift));\n  const res = BigNumber.from(mant).mul(BigNumber.from(2).pow(shift));\n  return res;\n}\n","import {\n  ASSERT,\n  calcInByOut,\n  calcOutByIn,\n  calcPrice,\n  closeValues,\n} from \"./MultiRouterMath\";\nimport {\n  MultiRoute,\n  Pool,\n  RToken,\n  RouteLeg,\n  RouteStatus,\n} from \"./MultiRouterTypes\";\n\nimport { BigNumber } from \"@ethersproject/bignumber\";\n\nexport class Edge {\n  readonly GasConsumption = 40_000;\n  readonly MINIMUM_LIQUIDITY = 1000;\n  pool: Pool;\n  vert0: Vertice;\n  vert1: Vertice;\n\n  canBeUsed: boolean;\n  direction: boolean;\n  amountInPrevious: number; // How many liquidity were passed from vert0 to vert1\n  amountOutPrevious: number; // How many liquidity were passed from vert0 to vert1\n  bestEdgeIncome: number; // debug data\n\n  constructor(p: Pool, v0: Vertice, v1: Vertice) {\n    this.pool = p;\n    this.vert0 = v0;\n    this.vert1 = v1;\n    this.amountInPrevious = 0;\n    this.amountOutPrevious = 0;\n    this.canBeUsed = true;\n    this.direction = true;\n    this.bestEdgeIncome = 0;\n  }\n\n  reserve(v: Vertice): BigNumber {\n    return v === this.vert0 ? this.pool.reserve0 : this.pool.reserve1;\n  }\n\n  calcOutput(v: Vertice, amountIn: number) {\n    const pool = this.pool;\n    let out,\n      gas = this.amountInPrevious ? 0 : this.GasConsumption;\n    if (v === this.vert1) {\n      if (this.direction) {\n        if (amountIn < this.amountOutPrevious) {\n          out =\n            this.amountInPrevious -\n            calcInByOut(pool, this.amountOutPrevious - amountIn, true);\n        } else {\n          out =\n            calcOutByIn(pool, amountIn - this.amountOutPrevious, false) +\n            this.amountInPrevious;\n        }\n        if (amountIn === this.amountOutPrevious) {\n          // TODO: accuracy?\n          gas = -this.GasConsumption;\n        }\n      } else {\n        out =\n          calcOutByIn(pool, this.amountOutPrevious + amountIn, false) -\n          this.amountInPrevious;\n      }\n    } else {\n      if (this.direction) {\n        out =\n          calcOutByIn(pool, this.amountInPrevious + amountIn, true) -\n          this.amountOutPrevious;\n      } else {\n        if (amountIn === this.amountInPrevious) {\n          // TODO: accuracy?\n          gas = -this.GasConsumption;\n        }\n        if (amountIn < this.amountInPrevious) {\n          out =\n            this.amountOutPrevious -\n            calcInByOut(pool, this.amountInPrevious - amountIn, false);\n        } else {\n          out =\n            calcOutByIn(pool, amountIn - this.amountInPrevious, true) +\n            this.amountOutPrevious;\n        }\n      }\n    }\n\n    // this.testApply(v, amountIn, out);\n\n    return [out, gas];\n  }\n\n  checkMinimalLiquidityExceededAfterSwap(\n    from: Vertice,\n    amountOut: number\n  ): boolean {\n    if (from === this.vert0) {\n      const r1 = parseInt(this.pool.reserve1.toString());\n      if (this.direction) {\n        return r1 - amountOut - this.amountOutPrevious < this.MINIMUM_LIQUIDITY;\n      } else {\n        return r1 - amountOut + this.amountOutPrevious < this.MINIMUM_LIQUIDITY;\n      }\n    } else {\n      const r0 = parseInt(this.pool.reserve0.toString());\n      if (this.direction) {\n        return r0 - amountOut + this.amountInPrevious < this.MINIMUM_LIQUIDITY;\n      } else {\n        return r0 - amountOut - this.amountInPrevious < this.MINIMUM_LIQUIDITY;\n      }\n    }\n  }\n\n  // doesn't used in production - just for testing\n  testApply(from: Vertice, amountIn: number, amountOut: number) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0);\n    const inPrev = this.direction\n      ? this.amountInPrevious\n      : -this.amountInPrevious;\n    const outPrev = this.direction\n      ? this.amountOutPrevious\n      : -this.amountOutPrevious;\n    const to = from.getNeibour(this);\n    let directionNew,\n      amountInNew = 0,\n      amountOutNew = 0;\n    if (to) {\n      const inInc = from === this.vert0 ? amountIn : -amountOut;\n      const outInc = from === this.vert0 ? amountOut : -amountIn;\n      const inNew = inPrev + inInc;\n      const outNew = outPrev + outInc;\n      if (inNew * outNew < 0) console.log(\"333\");\n      console.assert(inNew * outNew >= 0);\n      if (inNew >= 0) {\n        directionNew = true;\n        amountInNew = inNew;\n        amountOutNew = outNew;\n      } else {\n        directionNew = false;\n        amountInNew = -inNew;\n        amountOutNew = -outNew;\n      }\n    } else console.error(\"Error 221\");\n\n    if (directionNew) {\n      const calc = calcOutByIn(this.pool, amountInNew, directionNew);\n      const res = closeValues(amountOutNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-1 !!\",\n          amountOutNew,\n          calc,\n          Math.abs(calc / amountOutNew - 1)\n        );\n      return res;\n    } else {\n      const calc = calcOutByIn(this.pool, amountOutNew, directionNew);\n      const res = closeValues(amountInNew, calc, 1e-6);\n      if (!res)\n        console.log(\n          \"Err 225-2!!\",\n          amountInNew,\n          calc,\n          Math.abs(calc / amountInNew - 1)\n        );\n      return res;\n    }\n  }\n\n  applySwap(from: Vertice) {\n    console.assert(this.amountInPrevious * this.amountOutPrevious >= 0);\n    const inPrev = this.direction\n      ? this.amountInPrevious\n      : -this.amountInPrevious;\n    const outPrev = this.direction\n      ? this.amountOutPrevious\n      : -this.amountOutPrevious;\n    const to = from.getNeibour(this);\n    if (to) {\n      const inInc = from === this.vert0 ? from.bestIncome : -to.bestIncome;\n      const outInc = from === this.vert0 ? to.bestIncome : -from.bestIncome;\n      const inNew = inPrev + inInc;\n      const outNew = outPrev + outInc;\n      console.assert(inNew * outNew >= 0);\n      if (inNew >= 0) {\n        this.direction = true;\n        this.amountInPrevious = inNew;\n        this.amountOutPrevious = outNew;\n      } else {\n        this.direction = false;\n        this.amountInPrevious = -inNew;\n        this.amountOutPrevious = -outNew;\n      }\n    } else console.error(\"Error 221\");\n\n    ASSERT(() => {\n      if (this.direction)\n        return closeValues(\n          this.amountOutPrevious,\n          calcOutByIn(this.pool, this.amountInPrevious, this.direction),\n          1e-6\n        );\n      else {\n        return closeValues(\n          this.amountInPrevious,\n          calcOutByIn(this.pool, this.amountOutPrevious, this.direction),\n          1e-6\n        );\n      }\n    }, `Error 225`);\n  }\n}\n\nexport class Vertice {\n  token: RToken;\n  edges: Edge[];\n\n  price: number;\n  gasPrice: number;\n\n  bestIncome: number; // temp data used for findBestPath algorithm\n  gasSpent: number; // temp data used for findBestPath algorithm\n  bestTotal: number; // temp data used for findBestPath algorithm\n  bestSource?: Edge; // temp data used for findBestPath algorithm\n  checkLine: number; // debug data\n\n  constructor(t: RToken) {\n    this.token = t;\n    this.edges = [];\n    this.price = 0;\n    this.gasPrice = 0;\n    this.bestIncome = 0;\n    this.gasSpent = 0;\n    this.bestTotal = 0;\n    this.bestSource = undefined;\n    this.checkLine = -1;\n  }\n\n  getNeibour(e?: Edge) {\n    if (!e) return;\n    return e.vert0 === this ? e.vert1 : e.vert0;\n  }\n}\n\nexport class Graph {\n  vertices: Vertice[];\n  edges: Edge[];\n  tokens: Map<RToken, Vertice>;\n\n  constructor(pools: Pool[], baseToken: RToken, gasPrice: number) {\n    this.vertices = [];\n    this.edges = [];\n    this.tokens = new Map();\n    pools.forEach((p) => {\n      const v0 = this.getOrCreateVertice(p.token0);\n      const v1 = this.getOrCreateVertice(p.token1);\n      const edge = new Edge(p, v0, v1);\n      v0.edges.push(edge);\n      v1.edges.push(edge);\n      this.edges.push(edge);\n    });\n    const baseVert = this.tokens.get(baseToken);\n    if (baseVert) {\n      this.setPrices(baseVert, 1, gasPrice);\n    }\n  }\n\n  setPrices(from: Vertice, price: number, gasPrice: number) {\n    if (from.price !== 0) return;\n    from.price = price;\n    from.gasPrice = gasPrice;\n    const edges = from.edges\n      .map((e): [Edge, number] => [e, parseInt(e.reserve(from).toString())])\n      .sort(([_1, r1], [_2, r2]) => r2 - r1);\n    edges.forEach(([e, _]) => {\n      const v = e.vert0 === from ? e.vert1 : e.vert0;\n      if (v.price !== 0) return;\n      let p = calcPrice(e.pool, 0, false);\n      if (from === e.vert0) p = 1 / p;\n      this.setPrices(v, price * p, gasPrice / p);\n    });\n  }\n\n  getOrCreateVertice(token: RToken) {\n    let vert = this.tokens.get(token);\n    if (vert) return vert;\n    vert = new Vertice(token);\n    this.vertices.push(vert);\n    this.tokens.set(token, vert);\n    return vert;\n  }\n\n  exportPath(from: RToken, to: RToken) {\n    //}, _route: MultiRoute) {\n    // const allPools = new Map<string, Pool>();\n    // this.edges.forEach(p => allPools.set(p.address, p));\n    // const usedPools = new Map<string, boolean>();\n    // route.legs.forEach(l => usedPools.set(l.address, l.token === allPools.get(l.address)?.token0))\n\n    const fromVert = this.tokens.get(from) as Vertice;\n    const toVert = this.tokens.get(to) as Vertice;\n    const initValue = (fromVert.bestIncome * fromVert.price) / toVert.price;\n\n    const route = new Set<Edge>();\n    for (\n      let v = toVert;\n      v !== fromVert;\n      v = v.getNeibour(v.bestSource) as Vertice\n    ) {\n      if (v.bestSource) route.add(v.bestSource);\n    }\n\n    function edgeStyle(e: Edge) {\n      const finish = e.vert1.bestSource === e;\n      const start = e.vert0.bestSource === e;\n      let label;\n      if (e.bestEdgeIncome === -1) label = 'label: \"low_liq\"';\n      if (e.bestEdgeIncome !== 0)\n        label = `label: \"${print(\n          (e.bestEdgeIncome / initValue - 1) * 100,\n          3\n        )}%\"`;\n      const edgeValue = route.has(e) ? \"value: 2\" : undefined;\n      let arrow;\n      if (finish && start) arrow = 'arrows: \"from,to\"';\n      if (finish) arrow = 'arrows: \"to\"';\n      if (start) arrow = 'arrows: \"from\"';\n      return [\"\", label, edgeValue, arrow]\n        .filter((a) => a !== undefined)\n        .join(\", \");\n    }\n\n    function print(n: number, digits: number) {\n      let out;\n      if (n === 0) out = \"0\";\n      else {\n        const n0 = n > 0 ? n : -n;\n        const shift = digits - Math.ceil(Math.log(n0) / Math.LN10);\n        if (shift <= 0) out = `${Math.round(n0)}`;\n        else {\n          const mult = Math.pow(10, shift);\n          out = `${Math.round(n0 * mult) / mult}`;\n        }\n        if (n < 0) out = -out;\n      }\n      return out;\n    }\n\n    function nodeLabel(v: Vertice) {\n      const value = (v.bestIncome * v.price) / toVert.price;\n      const income = `${print(value, 3)}`;\n      const total = `${print(v.bestTotal, 3)}`;\n      // const income = `${print((value/initValue-1)*100, 3)}%`\n      // const total = `${print((v.bestTotal/initValue-1)*100, 3)}%`\n      const checkLine = v.checkLine === -1 ? undefined : `${v.checkLine}`;\n      return [checkLine, income, total]\n        .filter((a) => a !== undefined)\n        .join(\":\");\n    }\n\n    const nodes = `var nodes = new vis.DataSet([\n      ${this.vertices\n        .map((t) => `{ id: ${t.token.name}, label: \"${nodeLabel(t)}\"}`)\n        .join(\",\\n\\t\\t\")}\n    ]);\\n`;\n    const edges = `var edges = new vis.DataSet([\n      ${this.edges\n        .map(\n          (p) =>\n            `{ from: ${p.vert0.token.name}, to: ${\n              p.vert1.token.name\n            }${edgeStyle(p)}}`\n        )\n        .join(\",\\n\\t\\t\")}\n    ]);\\n`;\n    const data = `var data = {\n        nodes: nodes,\n        edges: edges,\n    };\\n`;\n\n    // TODO: This should be removed, this pacakge will not be installable on a client while this remains.\n    const fs = require(\"fs\");\n    fs.writeFileSync(\n      \"D:/Info/Notes/GraphVisualization/data.js\",\n      nodes + edges + data\n    );\n  }\n\n  findBestPath(\n    from: RToken,\n    to: RToken,\n    amountIn: number\n  ):\n    | {\n        path: Edge[];\n        output: number;\n        gasSpent: number;\n        totalOutput: number;\n      }\n    | undefined {\n    const start = this.tokens.get(from);\n    const finish = this.tokens.get(to);\n    if (!start || !finish) return;\n\n    this.edges.forEach((e) => (e.bestEdgeIncome = 0));\n    this.vertices.forEach((v) => {\n      v.bestIncome = 0;\n      v.gasSpent = 0;\n      v.bestTotal = 0;\n      v.bestSource = undefined;\n      v.checkLine = -1;\n    });\n    start.bestIncome = amountIn;\n    start.bestTotal = amountIn;\n    const processedVert = new Set<Vertice>();\n    const nextVertList = [start]; // TODO: Use sorted Set!\n\n    let checkLine = 0;\n    for (;;) {\n      let closestVert: Vertice | undefined;\n      let closestTotal = -1;\n      let closestPosition = 0;\n      nextVertList.forEach((v, i) => {\n        if (v.bestTotal > closestTotal) {\n          closestTotal = v.bestTotal;\n          closestVert = v;\n          closestPosition = i;\n        }\n      });\n\n      if (!closestVert) return;\n\n      closestVert.checkLine = checkLine++;\n\n      if (closestVert === finish) {\n        const bestPath = [];\n        for (\n          let v: Vertice | undefined = finish;\n          v?.bestSource;\n          v = v.getNeibour(v.bestSource)\n        ) {\n          bestPath.unshift(v.bestSource);\n        }\n        return {\n          path: bestPath,\n          output: finish.bestIncome,\n          gasSpent: finish.gasSpent,\n          totalOutput: finish.bestTotal,\n        };\n      }\n      nextVertList.splice(closestPosition, 1);\n\n      closestVert.edges.forEach((e) => {\n        const v2 = closestVert === e.vert0 ? e.vert1 : e.vert0;\n        if (processedVert.has(v2)) return;\n        let newIncome, gas;\n        try {\n          [newIncome, gas] = e.calcOutput(\n            closestVert as Vertice,\n            (closestVert as Vertice).bestIncome\n          );\n        } catch (e) {\n          // Any arithmetic error or out-of-liquidity\n          return;\n        }\n        if (\n          e.checkMinimalLiquidityExceededAfterSwap(\n            closestVert as Vertice,\n            newIncome\n          )\n        ) {\n          e.bestEdgeIncome = -1;\n          return;\n        }\n        const newGasSpent = (closestVert as Vertice).gasSpent + gas;\n        const price = v2.price / finish.price;\n        const newTotal = newIncome * price - newGasSpent * finish.gasPrice;\n\n        console.assert(e.bestEdgeIncome === 0, \"Error 373\");\n        e.bestEdgeIncome = newIncome * price;\n\n        if (!v2.bestSource) nextVertList.push(v2);\n        if (!v2.bestSource || newTotal > v2.bestTotal) {\n          v2.bestIncome = newIncome;\n          v2.gasSpent = newGasSpent;\n          v2.bestTotal = newTotal;\n          v2.bestSource = e;\n        }\n      });\n      processedVert.add(closestVert);\n    }\n  }\n\n  addPath(from: Vertice | undefined, to: Vertice | undefined, path: Edge[]) {\n    let _from = from;\n    path.forEach((e) => {\n      if (_from) {\n        e.applySwap(_from);\n        _from = _from.getNeibour(e);\n      } else {\n        console.error(\"Unexpected 315\");\n      }\n    });\n\n    ASSERT(() => {\n      const res = this.vertices.every((v) => {\n        let total = 0;\n        let totalModule = 0;\n        v.edges.forEach((e) => {\n          if (e.vert0 === v) {\n            if (e.direction) {\n              total -= e.amountInPrevious;\n            } else {\n              total += e.amountInPrevious;\n            }\n            totalModule += e.amountInPrevious;\n          } else {\n            if (e.direction) {\n              total += e.amountOutPrevious;\n            } else {\n              total -= e.amountOutPrevious;\n            }\n            totalModule += e.amountOutPrevious;\n          }\n        });\n        if (v === from) return total <= 0;\n        if (v === to) return total >= 0;\n        if (totalModule === 0) return total === 0;\n        return Math.abs(total / totalModule) < 1e10;\n      });\n      return res;\n    }, \"Error 290\");\n  }\n\n  findBestRoute(\n    from: RToken,\n    to: RToken,\n    amountIn: number,\n    mode: number | number[]\n  ): MultiRoute {\n    let routeValues = [];\n    if (Array.isArray(mode)) {\n      const sum = mode.reduce((a, b) => a + b, 0);\n      routeValues = mode.map((e) => e / sum);\n    } else {\n      for (let i = 0; i < mode; ++i) routeValues.push(1 / mode);\n    }\n\n    this.edges.forEach((e) => {\n      e.amountInPrevious = 0;\n      e.amountOutPrevious = 0;\n      e.direction = true;\n    });\n    let output = 0;\n    let gasSpentInit = 0;\n    //let totalOutput = 0\n    let totalrouted = 0;\n    let step;\n    for (step = 0; step < routeValues.length; ++step) {\n      const p = this.findBestPath(from, to, amountIn * routeValues[step]);\n      if (!p) {\n        break;\n      } else {\n        output += p.output;\n        gasSpentInit += p.gasSpent;\n        //totalOutput += p.totalOutput\n        this.addPath(this.tokens.get(from), this.tokens.get(to), p.path);\n        totalrouted += routeValues[step];\n      }\n    }\n    if (step == 0)\n      return {\n        status: RouteStatus.NoWay,\n        amountIn: 0,\n        amountOut: 0,\n        legs: [],\n        gasSpent: 0,\n        totalAmountOut: 0,\n      };\n    let status;\n    if (step < routeValues.length) status = RouteStatus.Partial;\n    else status = RouteStatus.Success;\n\n    const fromVert = this.tokens.get(from) as Vertice;\n    const toVert = this.tokens.get(to) as Vertice;\n    const [legs, gasSpent, topologyWasChanged] = this.getRouteLegs(\n      fromVert,\n      toVert\n    );\n    console.assert(gasSpent <= gasSpentInit, \"Internal Error 491\");\n\n    if (topologyWasChanged) {\n      output = this.calcLegsAmountOut(legs, amountIn, to);\n    }\n\n    return {\n      status,\n      amountIn: amountIn * totalrouted,\n      amountOut: output,\n      legs,\n      gasSpent,\n      totalAmountOut: output - gasSpent * toVert.gasPrice,\n    };\n  }\n\n  getRouteLegs(from: Vertice, to: Vertice): [RouteLeg[], number, boolean] {\n    const [nodes, topologyWasChanged] = this.cleanTopology(from, to);\n    const legs: RouteLeg[] = [];\n    let gasSpent = 0;\n    nodes.forEach((n) => {\n      const outEdges = this.getOutputEdges(n).map((e) => {\n        const from = this.edgeFrom(e);\n        return from ? [e, from[0], from[1]] : [e];\n      });\n\n      let outAmount = outEdges.reduce((a, b) => a + (b[2] as number), 0);\n      if (outAmount <= 0) return;\n\n      const total = outAmount;\n      outEdges.forEach((e, i) => {\n        const p = e[2] as number;\n        const quantity = i + 1 === outEdges.length ? 1 : p / outAmount;\n        legs.push({\n          address: (e[0] as Edge).pool.address,\n          token: n.token,\n          swapPortion: quantity,\n          absolutePortion: p / total,\n        });\n        gasSpent += (e[0] as Edge).pool.swapGasCost;\n        outAmount -= p;\n      });\n      console.assert(outAmount / total < 1e-12, \"Error 281\");\n    });\n    return [legs, gasSpent, topologyWasChanged];\n  }\n\n  edgeFrom(e: Edge): [Vertice, number] | undefined {\n    if (e.amountInPrevious === 0) return undefined;\n    return e.direction\n      ? [e.vert0, e.amountInPrevious]\n      : [e.vert1, e.amountOutPrevious];\n  }\n\n  getOutputEdges(v: Vertice): Edge[] {\n    return v.edges.filter((e) => {\n      if (!e.canBeUsed) return false;\n      if (e.amountInPrevious === 0) return false;\n      if (e.direction !== (e.vert0 === v)) return false;\n      return true;\n    });\n  }\n\n  getInputEdges(v: Vertice): Edge[] {\n    return v.edges.filter((e) => {\n      if (!e.canBeUsed) return false;\n      if (e.amountInPrevious === 0) return false;\n      if (e.direction === (e.vert0 === v)) return false;\n      return true;\n    });\n  }\n\n  calcLegsAmountOut(legs: RouteLeg[], amountIn: number, to: RToken) {\n    const amounts = new Map<RToken, number>();\n    amounts.set(legs[0].token, amountIn);\n    legs.forEach((l) => {\n      const vert = this.tokens.get(l.token);\n      console.assert(vert !== undefined, \"Internal Error 570\");\n      const edge = (vert as Vertice).edges.find(\n        (e) => e.pool.address === l.address\n      );\n      console.assert(edge !== undefined, \"Internel Error 569\");\n      const pool = (edge as Edge).pool;\n      const direction = vert === (edge as Edge).vert0;\n\n      const inputTotal = amounts.get(l.token);\n      console.assert(inputTotal !== undefined, \"Internal Error 564\");\n      const input = (inputTotal as number) * l.swapPortion;\n      amounts.set(l.token, (inputTotal as number) - input);\n      const output = calcOutByIn(pool, input, direction);\n\n      const vertNext = (vert as Vertice).getNeibour(edge) as Vertice;\n      const prevAmount = amounts.get(vertNext.token);\n      amounts.set(vertNext.token, (prevAmount || 0) + output);\n    });\n    return amounts.get(to) || 0;\n  }\n\n  // removes all cycles if there are any, then removes all dead end could appear after cycle removing\n  // Returns clean result topologically sorted\n  cleanTopology(from: Vertice, to: Vertice): [Vertice[], boolean] {\n    let topologyWasChanged = false;\n    let result = this.topologySort(from, to);\n    if (result[0] !== 2) {\n      topologyWasChanged = true;\n      console.assert(result[0] === 0, \"Internal Error 554\");\n      while (result[0] === 0) {\n        this.removeWeakestEdge(result[1]);\n        result = this.topologySort(from, to);\n      }\n      if (result[0] === 3) {\n        this.removeDeadEnds(result[1]);\n        result = this.topologySort(from, to);\n      }\n      console.assert(result[0] === 2, \"Internal Error 563\");\n      if (result[0] !== 2) return [[], topologyWasChanged];\n    }\n    return [result[1], topologyWasChanged];\n  }\n\n  removeDeadEnds(verts: Vertice[]) {\n    verts.forEach((v) => {\n      this.getInputEdges(v).forEach((e) => {\n        e.canBeUsed = false;\n      });\n    });\n  }\n\n  removeWeakestEdge(verts: Vertice[]) {\n    let minVert: Vertice, minVertNext: Vertice;\n    let minOutput = Number.MAX_VALUE;\n    verts.forEach((v1, i) => {\n      const v2 = i === 0 ? verts[verts.length - 1] : verts[i - 1];\n      let out = 0;\n      this.getOutputEdges(v1).forEach((e) => {\n        if (v1.getNeibour(e) !== v2) return;\n        out += e.direction ? e.amountOutPrevious : e.amountInPrevious;\n      });\n      if (out < minOutput) {\n        minVert = v1;\n        minVertNext = v2;\n        minOutput = out;\n      }\n    });\n    // @ts-ignore\n    this.getOutputEdges(minVert).forEach((e) => {\n      if (minVert.getNeibour(e) !== minVertNext) return;\n      e.canBeUsed = false;\n    });\n  }\n\n  // topological sort\n  // if there is a cycle - returns [0, <List of envolved vertices in the cycle>]\n  // if there are no cycles but deadends- returns [3, <List of all envolved deadend vertices>]\n  // if there are no cycles or deadends- returns [2, <List of all envolved vertices topologically sorted>]\n  topologySort(from: Vertice, to: Vertice): [number, Vertice[]] {\n    // undefined or 0 - not processed, 1 - in process, 2 - finished, 3 - dedend\n    const vertState = new Map<Vertice, number>();\n    const vertsFinished: Vertice[] = [];\n    const foundCycle: Vertice[] = [];\n    const foundDeadEndVerts: Vertice[] = [];\n\n    const that = this;\n    // 0 - cycle was found and created, return\n    // 1 - during cycle creating\n    // 2 - vertex is processed ok\n    // 3 - dead end vertex\n    function topSortRecursive(current: Vertice): number {\n      const state = vertState.get(current);\n      if (state === 2 || state === 3) return state;\n      if (state === 1) {\n        console.assert(foundCycle.length == 0, \"Internal Error 566\");\n        foundCycle.push(current);\n        return 1;\n      }\n      vertState.set(current, 1);\n\n      let successors2Exist = false;\n      const outEdges = that.getOutputEdges(current);\n      for (let i = 0; i < outEdges.length; ++i) {\n        const e = outEdges[i];\n        const res = topSortRecursive(current.getNeibour(e) as Vertice);\n        if (res === 0) return 0;\n        if (res === 1) {\n          if (foundCycle[0] === current) return 0;\n          else {\n            foundCycle.push(current);\n            return 1;\n          }\n        }\n        if (res === 2) successors2Exist = true; // Ok successors\n      }\n      if (successors2Exist) {\n        console.assert(current !== to, \"Internal Error 589\");\n        vertsFinished.push(current);\n        vertState.set(current, 2);\n        return 2;\n      } else {\n        if (current !== to) {\n          foundDeadEndVerts.push(current);\n          vertState.set(current, 3);\n          return 3;\n        }\n        vertsFinished.push(current);\n        vertState.set(current, 2);\n        return 2;\n      }\n    }\n\n    const res = topSortRecursive(from);\n    if (res === 0) return [0, foundCycle];\n    if (foundDeadEndVerts.length) return [3, foundDeadEndVerts];\n    ASSERT(() => {\n      if (vertsFinished[0] !== to) return false;\n      if (vertsFinished[vertsFinished.length - 1] !== from) return false;\n      return true;\n    }, \"Internal Error 614\");\n    if (res === 2) return [2, vertsFinished.reverse()];\n    console.assert(true, \"Internal Error 612\");\n    return [1, []];\n  }\n}\n\nexport function findMultiRouting(\n  from: RToken,\n  to: RToken,\n  amountIn: number,\n  pools: Pool[],\n  baseToken: RToken,\n  gasPrice: number,\n  steps: number | number[] = 12\n): MultiRoute {\n  const g = new Graph(pools, baseToken, gasPrice);\n  const fromV = g.tokens.get(from);\n  if (fromV?.price === 0) {\n    g.setPrices(fromV, 1, 0);\n  }\n  const out = g.findBestRoute(from, to, amountIn, steps);\n  return out;\n}\n"],"names":["PoolType","RouteStatus","Pool","_info","info","minLiquidity","swapGasCost","address","token0","token1","type","reserve0","reserve1","fee","RConstantProductPool","_Pool","ConstantProduct","RHybridPool","Hybrid","A","RWeightedPool","Weighted","weight0","weight1","RConcentratedLiquidityPool","ConcentratedLiquidity","BigNumber","from","liquidity","sqrtPrice","nearestTick","ticks","DCacheBN","Map","HybridComputeLiquidity","pool","res","get","undefined","r0","r1","isZero","set","prevD","s","add","nA","D","i","dP","mul","div","sub","abs","lte","HybridgetY","x","yPrev","c","b","y","calcOutByIn","amountIn","direction","xBN","yBN","parseInt","toString","Math","pow","yNewBN","getBigNumber","inAmount","length","index","unshift","DLiquidity","push","nextTickToCross","currentPrice","currentLiquidity","outAmount","input","OutOfLiquidity","nextTickPrice","sqrt","output","maxDx","maxDy","ConcentratedLiquidityOutByIn","Error","calcInByOut","amountOut","lt","xNewBN","round","console","error","calcPrice","takeFeeIntoAccount","oneMinusFee","weightRatio","hPool","ac4","ASSERT","f","t","closeValues","a","accuracy","revertPositive","out","hint","min","max","x0","y0","e","valueBN","value","Number","MAX_SAFE_INTEGER","exp","floor","log","LN2","assert","shift","mant","Edge","p","v0","v1","vert0","vert1","amountInPrevious","amountOutPrevious","canBeUsed","bestEdgeIncome","reserve","v","this","calcOutput","gas","GasConsumption","checkMinimalLiquidityExceededAfterSwap","MINIMUM_LIQUIDITY","testApply","directionNew","inPrev","outPrev","amountInNew","amountOutNew","getNeibour","inNew","outNew","calc","applySwap","to","bestIncome","_this","Vertice","token","edges","price","gasPrice","gasSpent","bestTotal","bestSource","checkLine","Graph","pools","baseToken","vertices","tokens","forEach","_this2","getOrCreateVertice","edge","baseVert","setPrices","map","sort","_this3","vert","exportPath","fromVert","toVert","initValue","route","Set","print","n","digits","n0","ceil","LN10","mult","nodes","name","income","total","filter","join","nodeLabel","finish","start","label","arrow","has","require","writeFileSync","findBestPath","processedVert","nextVertList","closestVert","closestTotal","closestPosition","bestPath","_v","path","totalOutput","splice","v2","newIncome","newGasSpent","newTotal","addPath","_from","_this4","every","totalModule","findBestRoute","mode","routeValues","Array","isArray","sum","reduce","step","status","gasSpentInit","totalrouted","NoWay","legs","totalAmountOut","Partial","Success","getRouteLegs","topologyWasChanged","calcLegsAmountOut","cleanTopology","outEdges","_this5","getOutputEdges","edgeFrom","swapPortion","absolutePortion","getInputEdges","amounts","l","_this6","find","inputTotal","vertNext","prevAmount","result","topologySort","removeWeakestEdge","removeDeadEnds","verts","_this7","minVert","minVertNext","minOutput","MAX_VALUE","_this8","vertState","vertsFinished","foundCycle","foundDeadEndVerts","that","topSortRecursive","current","state","successors2Exist","reverse","priceEffective","calcInputByPriceConstantMean","sqrtD","steps","g","fromV"],"mappings":"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"}